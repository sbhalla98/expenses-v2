import { RECURRING_FREQUENCY } from "@/lib/constants";
import clientPromise from "@/lib/mongodb";
import { RecurringExpense } from "@/lib/types";
import { NextResponse } from "next/server";
import { v4 as uuidv4 } from "uuid";

export async function GET(request: Request) {
  try {
    // Verify cron secret if needed (skipping for now as per plan, but good practice)
    // const authHeader = request.headers.get('authorization');
    // if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) { ... }

    const client = await clientPromise;
    const db = client.db("expenses-v2");
    const recurringCollection = db.collection("recurring-expenses");
    const expensesCollection = db.collection("expenses");

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const recurringExpenses = (await recurringCollection
      .find({})
      .toArray()) as unknown as RecurringExpense[];
    const processed = [];

    for (const expense of recurringExpenses) {
      const nextPaymentDate = new Date(expense.nextPaymentDate);
      nextPaymentDate.setHours(0, 0, 0, 0);

      if (nextPaymentDate <= today) {
        // Create new expense
        const newExpense = {
          id: uuidv4(),
          amount: expense.amount,
          category: expense.category,
          date: nextPaymentDate.toISOString(), // Use the due date, not necessarily today
          description: expense.description + " (Auto-recurring)",
          paidBy: expense.paidBy,
          paidFor: expense.paidFor,
          userId: expense.userId,
          autoGenerated: true,
          recurringId: expense.id,
        };

        await expensesCollection.insertOne(newExpense);

        // Calculate next payment date
        const newNextPaymentDate = new Date(nextPaymentDate);
        switch (expense.frequency) {
          case RECURRING_FREQUENCY.DAILY:
            newNextPaymentDate.setDate(newNextPaymentDate.getDate() + 1);
            break;
          case RECURRING_FREQUENCY.WEEKLY:
            newNextPaymentDate.setDate(newNextPaymentDate.getDate() + 7);
            break;
          case RECURRING_FREQUENCY.MONTHLY:
            newNextPaymentDate.setMonth(newNextPaymentDate.getMonth() + 1);
            break;
          case RECURRING_FREQUENCY.YEARLY:
            newNextPaymentDate.setFullYear(
              newNextPaymentDate.getFullYear() + 1,
            );
            break;
        }

        // Update recurring expense
        await recurringCollection.updateOne(
          { id: expense.id },
          { $set: { nextPaymentDate: newNextPaymentDate.toISOString() } },
        );

        processed.push({
          recurringId: expense.id,
          newExpenseId: newExpense.id,
          newNextPaymentDate: newNextPaymentDate.toISOString(),
        });
      }
    }

    return NextResponse.json({
      success: true,
      processedCount: processed.length,
      processed,
    });
  } catch (e) {
    console.error("Error processing recurring expenses:", e);
    return NextResponse.json(
      {
        success: false,
        message: "Error processing recurring expenses",
        error: e,
      },
      { status: 500 },
    );
  }
}
